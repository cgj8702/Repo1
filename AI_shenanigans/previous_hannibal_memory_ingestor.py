# -*- coding: utf-8 -*-
"""Hannibal Memory Ingestor

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Z9jcy54MDHV8p8zQYb4BW0QOV3tUK5DX
"""

import re
import os
import json
import pdfplumber
from tqdm import tqdm

# --- CONFIGURATION ---
SCRIPTS_FOLDER = "C:/Users/carly/Documents/Coding/episode_scripts/"
OUTPUT_FOLDER = "C:/Users/carly/Documents/Coding/Hannibal_memories/"
os.makedirs(OUTPUT_FOLDER, exist_ok=True)

class HannibalParser:
    def __init__(self):
        # Regex for lines that are purely technical and provide no narrative value
        self.junk_lines = [
            r"^\d+\.$",                  # Page numbers with dots
            r"^\d+$",                    # Page numbers
            r"^\(CONTINUED\)$",          # Page break markers
            r"^CONTINUED:$",             # Page break markers
            r"^OMITTED$",                # Production notes
            r"^HANNIBAL.*#\d+",          # Header junk
            r"^\s*\(.*?\)\s*$"           # Empty parentheticals
        ]

        # Terms that indicate a state of mind or time shift
        self.meta_markers = {
            "DREAM": ["DREAM", "NIGHTMARE", "HALLUCINATION", "SURREAL"],
            "FLASHBACK": ["FLASHBACK", "MEMORY", "PREVIOUSLY"],
            "POV": ["POV", "POINT OF VIEW", "THROUGH THE"],
            "TIME": ["LATER", "MOMENTS LATER", "CONTINUOUS", "SAME TIME", "DAY", "NIGHT"]
        }

    def clean_text(self, text):
        """Gentle cleaning. Removes technical artifacts but keeps narrative flavor."""
        # Remove (CONT'D), (V.O.), (O.S.) but keep the text flowing
        text = re.sub(r"\s*\((?:CONT'D|cont'd|V\.O\.|O\.S\.|into phone)\)", "", text, flags=re.IGNORECASE)
        return text.strip()

    def transform_observation(self, text):
        """Crucial for Hannibal: Transforms camera direction into narrative observation."""
        # "OFF WILL" -> "Observation: Will reacts."
        match = re.search(r"^(?:OFF|ON)\s+([A-Z0-9\s\-]+)(.*)", text, re.IGNORECASE)
        if match:
            target = match.group(1).strip().title() # Convert "WILL" to "Will"
            description = match.group(2).strip().strip(",.-")
            if not description:
                return f"[Observation: Focus is on {target}]"
            return f"[Observation: {target} reacts: {description}]"

        # "REVEAL..." -> "We see..."
        if text.upper().startswith("REVEAL"):
            return "We see " + text[6:].strip()

        return text

    def extract_scene_metadata(self, heading):
        """Extracts rich metadata from the slugline."""
        meta = {
            "is_dream": False,
            "is_flashback": False,
            "pov": None,
            "time_of_day": "UNKNOWN",
            "location": "UNKNOWN",
            "characters_present": [] # Will be populated during parsing
        }

        heading_upper = heading.upper()

        # Check markers
        for key in self.meta_markers["DREAM"]:
            if key in heading_upper: meta["is_dream"] = True
        for key in self.meta_markers["FLASHBACK"]:
            if key in heading_upper: meta["is_flashback"] = True
        if "POV" in heading_upper:
            meta["pov"] = "Specific POV"

        # Extract Location (Rough heuristic: Everything between INT./EXT. and the Dash)
        loc_match = re.search(r"(?:INT\.|EXT\.|I/E)\s+(.*?)(?:\s-\s|$)", heading_upper)
        if loc_match:
            meta["location"] = loc_match.group(1).strip()

        return meta

    def get_line_type(self, raw_line):
        """Determines line type based on indentation (geometry)."""
        clean = raw_line.strip()
        if not clean: return "EMPTY"

        # Indentation calculation (approximate spaces)
        leading_spaces = len(raw_line) - len(raw_line.lstrip())

        # 1. SCENE HEADINGS (Left aligned, usually specific keywords)
        if leading_spaces < 10 and any(k in clean for k in ["INT.", "EXT.", "I/E", "INT/EXT"]):
            return "HEADING"

        # 2. TRANSITIONS (Far right, usually CUT TO:)
        if leading_spaces > 45 and (clean.endswith("TO:") or clean.startswith("FADE")):
            return "TRANSITION"

        # 3. CHARACTER NAMES (Deep indentation, All Caps)
        if 28 <= leading_spaces <= 42 and clean.isupper() and len(clean) < 50:
            return "CHARACTER"

        # 4. DIALOGUE (Medium indentation)
        if 15 <= leading_spaces <= 27:
            if clean.startswith("("): return "PARENTHETICAL"
            return "DIALOGUE"

        # 5. ACTION (Left aligned or slight indent)
        # Includes "OFF WILL" and "ON HANNIBAL" which are technically shots but we treat as action
        if leading_spaces < 15:
            return "ACTION"

        return "UNKNOWN"

    def parse_pdf(self, pdf_path):
        scenes = []
        current_scene = None
        current_buffer = [] # Holds text for the current block (e.g. multi-line action)
        last_type = None
        active_speaker = None

        tqdm.write(f"Parsing: {os.path.basename(pdf_path)}")

        with pdfplumber.open(pdf_path) as pdf:
            # Skip page 1 (Title Page) usually
            for page in pdf.pages[1:]:
                text = page.extract_text(layout=True)
                if not text: continue

                lines = text.split('\n')

                for line in lines:
                    # 1. Skip Junk
                    if any(re.search(regex, line.strip()) for regex in self.junk_lines):
                        continue

                    line_type = self.get_line_type(line)
                    content = line.strip()

                    # --- NEW SCENE ---
                    if line_type == "HEADING":
                        # Save previous scene
                        if current_scene:
                            current_scene["content"] = "\n".join(current_buffer)
                            scenes.append(current_scene)

                        # Start new scene
                        clean_heading = self.clean_text(content)
                        current_scene = {
                            "heading": clean_heading,
                            "metadata": self.extract_scene_metadata(clean_heading),
                            "content": "" # Placeholder
                        }
                        current_buffer = []
                        last_type = "HEADING"
                        active_speaker = None
                        continue

                    # --- CHARACTER NAME ---
                    if line_type == "CHARACTER":
                        active_speaker = self.clean_text(content)
                        # Add to character list in metadata
                        if current_scene and active_speaker not in current_scene["metadata"]["characters_present"]:
                            current_scene["metadata"]["characters_present"].append(active_speaker)
                        last_type = "CHARACTER"
                        continue

                    # --- DIALOGUE ---
                    if line_type == "DIALOGUE":
                        if active_speaker:
                            # Format: HANNIBAL: "Hello Will."
                            # If continuing dialogue, append to previous line if possible, or new line
                            formatted_line = f'{active_speaker}: "{self.clean_text(content)}"'
                            current_buffer.append(formatted_line)
                        last_type = "DIALOGUE"
                        continue

                    # --- PARENTHETICAL ---
                    if line_type == "PARENTHETICAL":
                        # Add as narrative texture: (whispering)
                        clean_paren = content.lower().replace("(", "").replace(")", "")
                        if active_speaker:
                            current_buffer.append(f"[{active_speaker} {clean_paren}]")
                        last_type = "PARENTHETICAL"
                        continue

                    # --- ACTION / OBSERVATION ---
                    if line_type == "ACTION":
                        # Transform "OFF WILL" -> "Observation: Will reacts"
                        transformed = self.transform_observation(content)

                        # Merge logic: If previous line was action, merge for flow
                        if last_type == "ACTION" and current_buffer:
                            current_buffer[-1] += " " + transformed
                        else:
                            current_buffer.append(transformed)

                        last_type = "ACTION"
                        active_speaker = None # Reset speaker
                        continue

        # Flush final scene
        if current_scene:
            current_scene["content"] = "\n".join(current_buffer)
            scenes.append(current_scene)

        return scenes

# --- EXECUTION ---
parser = HannibalParser()
pdf_files = [f for f in os.listdir(SCRIPTS_FOLDER) if f.endswith(".pdf")]

for filename in tqdm(pdf_files):
    full_path = os.path.join(SCRIPTS_FOLDER, filename)
    data = parser.parse_pdf(full_path)

    # Save JSON with rich structure for RAG
    out_name = os.path.splitext(filename)[0] + "_memory.json"
    with open(os.path.join(OUTPUT_FOLDER, out_name), "w", encoding="utf-8") as f:
        json.dump(data, f, indent=4)

    # Save Readable Text for Debugging
    debug_name = os.path.splitext(filename)[0] + "_readable.txt"
    with open(os.path.join(OUTPUT_FOLDER, debug_name), "w", encoding="utf-8") as f:
        for scene in data:
            f.write(f"\n=== {scene['heading']} ===\n")
            f.write(f"[META: {scene['metadata']}]\n")
            f.write(scene['content'] + "\n")
            f.write("-" * 40 + "\n")

print("Processing Complete. Memory Palace Constructed.")